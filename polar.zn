// https://xgm.guru/p/wc3/polar
//! zinc
library Polar {
    constant integer AbilityUnitZ = 'Amrf';
    location locationZ = Location(0, 0);

    public {
        function GetPolarOffsetX(real x, real distance, real angle) -> real {
            return x + distance * Cos(angle * bj_DEGTORAD);
        }
        function GetPolarOffsetY(real y, real distance, real angle) -> real {
            return y + distance * Sin(angle * bj_DEGTORAD);
        }

        function MoveLocationPolar(location target, real distance, real angle){
            real x = GetPolarOffsetX(GetLocationX(target), distance, angle);
            real y = GetPolarOffsetY(GetLocationY(target), distance, angle);
            MoveLocation(target, x, y);
        }

        function SetUnitPositionPolar(unit target, real distance, real angle){
            SetUnitX(target, GetPolarOffsetX(GetUnitX(target), distance, angle));
            SetUnitY(target, GetPolarOffsetY(GetUnitY(target), distance, angle));
        }

        function AngleBetweenCoords(real x1, real y1, real x2, real y2) -> real {
            return bj_RADTODEG * Atan2(y2 - y1, x2 - x1);
        }
        function AngleBetweenWidgets(widget target1, widget target2) -> real {
            return AngleBetweenCoords(GetWidgetX(target1), GetWidgetY(target1), GetWidgetX(target2), GetWidgetY(target2));
        }

        function DistanceBetweenCoords(real x1, real y1, real x2, real y2) -> real {
            real dx = x2 - x1;
            real dy = y2 - y1;
            return SquareRoot(dx*dx + dy*dy);
        }
        function DistanceBetweenCoords3D(real x1, real y1, real z1, real x2, real y2, real z2) -> real {
            real dx = x2 - x1;
            real dy = y2 - y1;
            real dz = z2 - z1;
            return SquareRoot(dx*dx + dy*dy + dz*dz);
        }

        function DistanceBetweenWidgets(widget target1, widget target2) -> real {
            return DistanceBetweenCoords(GetWidgetX(target1), GetWidgetY(target1), GetWidgetX(target2), GetWidgetY(target2));
        }

        function GetTerrainZ(real x, real y) -> real {
            MoveLocation(locationZ, x, y);
            return GetLocationZ(locationZ);
        }
        function GetUnitZ(unit target) -> real {
            return GetTerrainZ(GetUnitX(target), GetUnitY(target)) + GetUnitFlyHeight(target);
        }

        function UnitAddAbilityZ(unit target){
            if (GetUnitAbilityLevel(target, AbilityUnitZ) == 0){ UnitAddAbility(target, AbilityUnitZ); }
        }
        function UnitRemoveAbilityZ(unit target){
            if (GetUnitAbilityLevel(target, AbilityUnitZ) > 0){ UnitRemoveAbility(target, AbilityUnitZ); }
        }

        function SetUnitZ(unit target, real z) -> unit {
            SetUnitFlyHeight(target, z - GetTerrainZ(GetUnitX(target), GetUnitY(target)), 0);
            return target;
        }
        function SetUnitXY(unit target, real x, real y) -> unit {
            SetUnitX(target, x);
            SetUnitY(target, y);
            return target;
        }
        function SetUnitXYZ(unit target, real x, real y, real z) -> unit {
            SetUnitXY(target, x, y);
            SetUnitZ(target, z);
            return target;
        }
        function SetUnitXYZF(unit target, real x, real y, real z, real f) -> unit {
            SetUnitXY(target, x, y);
            SetUnitZ(target, z);
            SetUnitFacing(target, f);
            return target;
        }



        // https://xgm.guru/p/wc3/perpendicular
        // Находит длину перпендикуляра от отрезка, заданного Xa, Ya, Xb, Yb к точке, заданной Xc, Yc.
        function Perpendicular (real Xa, real Ya, real Xb, real Yb, real Xc, real Yc) -> real {
            return SquareRoot((Xa - Xc) * (Xa - Xc) + (Ya - Yc) * (Ya - Yc)) * Sin(Atan2(Yc-Ya,Xc-Xa) - Atan2(Yb-Ya,Xb-Xa));
        }


        // https://xgm.guru/p/wc3/warden-math
        // Расстояние между двумя углами
        function AngleDifference(real a1, real a2) -> real {
            real x;
            a1 = ModuloReal(a1, 360);
            a2 = ModuloReal(a2, 360);
            if (a1 > a2) {
                x = a1;
                a1 = a2;
                a2 = x;
            }
            x = a2 - 360;
            if (a2 - a1 > a1 - x){
                a2 = x;
            }
            return RAbsBJ(a1 - a2);
        }

        /*
            h - максимальная высота на середине расстояния
            d - общее расстояние до цели
            x - расстояние от исходной цели до точки
        */
        function ParabolaZ(real h, real d, real x) -> real {
            return (4 * h / d) * (d - x) * (x / d);
        }

        /*
            zs - начальная высота высота одного края дуги
            ze - конечная высота высота другого края дуги
            h  - максимальная высота на середине расстояния
            d  - общее расстояние до цели
            x  - расстояние от исходной цели до точки
        */
        function ParabolaZ2(real zs, real ze, real h, real d, real x) -> real {
            return (2*(zs + ze - 2*h)*(x/d - 1) + (ze - zs))*(x/d) + zs;
        }

        // Приводит угол в божеский вид
        function AngleNormalize(real angle) -> real {
            if (angle > 360){ angle = angle - 360; }
            if (angle < 0){ angle = 360 + angle; }
            return angle;
        }

    }
}
//! endzinc