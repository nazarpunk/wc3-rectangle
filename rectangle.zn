//! zinc
    library Rectangle {

        // Помещает любой угол в радианах в диапазон [0 ... 2PI]
        function normalize (real r) -> real {
            return r - 2 * bj_PI * R2I(r / (bj_PI * 2));
        }

        public struct Rectangle {
            real tlX, tlY, trX, trY, blX, blY, brX, brY;
    
            real cX, cY;
    
            real angle;
    
            real width, height, diagonal;
    
            // Создаёт новый прямоугольник с центром в точке [cX, cY]
            // шириной width и высотой height
            // и углом angle, задаваемого в радианах
            static method create(real cX, real cY, real width, real height, real angle) -> Rectangle {
                Rectangle this = Rectangle.allocate();
                this.cX = cX;
                this.cY = cY;
                this.width = width;
                this.height = height;
                this.angle = angle;
                this.setAngle(angle);
                return this;
            }

            method destroy() {
                this.deallocate();
            }
    
            // Устанавливает угол поворота прямоугольника в радианах
            method setAngle(real angle) {
                real wa = (bj_PI - Atan(this.height / this.width) * 2) * .5;
                real ar, d;

                this.angle = normalize(angle);
                this.diagonal = SquareRoot(this.width * this.width + this.height * this.height);
                d = this.diagonal * .5;
    
                ar = normalize(angle - wa);
                this.trX = this.cX + d * Cos(ar);
                this.trY = this.cY + d * Sin(ar);
    
                ar = normalize(angle + wa);
                this.tlX = this.cX + d * Cos(ar);
                this.tlY = this.cY + d * Sin(ar);
    
                angle = angle + bj_PI;
    
                ar = normalize(angle - wa);
                this.blX = this.cX + d * Cos(ar);
                this.blY = this.cY + d * Sin(ar);
    
                ar = normalize(angle + wa);
                this.brX = this.cX + d * Cos(ar);
                this.brY = this.cY + d * Sin(ar);
            }
    
            // Возвращает квадрат расстояния между точкой [x,y]
            // и ближайшей точкой прямоугольника
            method distanceToXY(real x, real y) -> real {
                real a = normalize(0 - this.angle);
                real cos = Cos(a);
                real sin = Sin(a);
                real xn, yn, dx , dy ;
                real hh = this.height * .5;
                real hw = this.width * .5;

                x = x - this.cX;
                y = y - this.cY;
                xn = x * cos - y * sin;
                yn = x * sin + y * cos;
                x = xn + this.cX;
                y = yn + this.cY;

                dx = RMaxBJ(0, RMaxBJ(this.cX - hh - x, x - (this.cX + hh)));
                dy = RMaxBJ(0, RMaxBJ(this.cY - hw - y, y - (this.cY + hw)));
    
                return dx * dx + dy * dy;
            }

            // Смещает все точки прямоугольника
            method translate(real tx, real ty) -> real {
                this.cX = this.cX + tx;
                this.cY = this.cY + ty;

                this.tlX = this.tlX + tx;
                this.tlY = this.tlY + ty;
                this.trX = this.trX + tx;
                this.trY = this.trY + ty;
                this.blX = this.blX + tx;
                this.blY = this.blY + ty;
                this.brX = this.brX + tx;
                this.brY = this.brY + ty;
            }
        }
    }

//! endzinc
